import haxe.extern.EitherType;
import vscode.CancellationToken;
import vscode.CodeAction;
import vscode.CodeActionContext;
import vscode.CodeActionKind;
import vscode.Command;
import vscode.Diagnostic;
import vscode.Position;
import vscode.ProviderResult;
import vscode.Range;
import vscode.TextDocument;
import vscode.WorkspaceEdit;

using StringTools;

/**
 * This class provides the custom code actions which allow users to fix issues using the context menu.
 * 
 * Many of the classes and functions used here are hooks into VSCode's API, provided by the main Haxe extension.
 * @see https://vshaxe.github.io/vscode-extern/
 */
class CheckstyleCodeActions {
	public function new() {}

	/**
	 * The title for the code action which executes all auto-fixes in the selected range.
	 */
	static final TITLE_FIX_ALL = "Fix all style problems";

	/**
	 * This function is run as a callback by VSCode, and provides the necessary data
	 * for a list of automated code actions to be generated.
	 * 
	 * @param document Contains metadata about the document as well as all of its text.
	 * @param range The range of positions in the document to provide code actions for.
	 * @param context Contains context for the code actions to be generated.
	 *   The important thing here is `context.diagnostics` which contains a list of all the errors in the range,
	 * 	 some of which were generated by haxe-checkstyle.
	 * @param token Provides info about whether the operation should be cancelled, such as if the user starts typing
	 * 	 while code actions are being determined.
	 * @return ProviderResult<Array<EitherType<Command, CodeAction>>>
	 */
	public function provideCodeActions(document:TextDocument, range:Range, context:CodeActionContext,
			token:CancellationToken):ProviderResult<Array<EitherType<Command, CodeAction>>> {
		/**
		 * A list of code actions to perform, which we build in a Map.
		 * This allows code actions with the same title to be combined.
		 */
		var actions:Map<String, CodeAction> = new Map<String, CodeAction>();

		// For each problem within the document...
		for (diag in context.diagnostics) {
			// Check if it was created by haxe-checkstyle
			if (diag.source != "checkstyle") {
				continue;
			}
			// Check if it is within the current selection.
			if (range.intersection(diag.range) == null) {
				continue;
			}
			// Create a code action for it.
			makeCheckAction(document, actions, diag);
		}

		// Move the code actions from the map to the output array and submit it.
		var commands:Array<EitherType<Command, CodeAction>> = [];
		for (name in actions.keys()) {
			var action = actions.get(name);
			if (action.diagnostics.length > 1) {
				renameCodeAction(action);
			}
			commands.push(action);
		}
		return commands;
	}

	public function resolveCodeAction(codeAction:CodeAction, token:CancellationToken):ProviderResult<CodeAction> {
		if (token.isCancellationRequested)
			return codeAction;
		return codeAction;
	}

	/**
	 * Given a code action, rename it as appropriate.
	 * If it contains multiple diagnostics, count them up.
	 */
	function renameCodeAction(codeAction:CodeAction) {
		// Count the number of actions used.
		var actionCount = codeAction.diagnostics.length;
		var actionTitle = codeAction.title;
		switch (actionTitle) {
			case "Change single quotes to double quotes":
				// This fix performs two actions.
				actionCount = Math.round(actionCount / 2);
			case "Change double quotes to single quotes":
				// This fix performs two actions.
				actionCount = Math.round(actionCount / 2);
			case TITLE_FIX_ALL:
				// Don't rename the action.
				return;
		}

		// Rename the action to indicate the number of issues in the range.
		codeAction.title = 'Fix $actionCount instances of "$actionTitle"';
	}

	/**
	 * This is the builder function which generates a code action based on the provided diagnostic
	 * along with the document that contains it.
	 * 
	 * We don't redo the work of haxe-checkstyle! We combine the `diag.code` value
	 * with regex parsing of `diag.message` to figure out what to change.
	 * @param document The document that the problem is in.
	 * @param actions The map of code actions to add to. If an action of the same name is already in the list,
	 * 	 we'll combine them.
	 * @param diag The problem to create code actions for.
	 */
	function makeCheckAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic) {
		var index = diag.message.indexOf(" - ");
		if (index <= 0) {
			return;
		}
		// Parse which code action to use by the problem name at the beginning of the message.
		var checkName:CheckNames = diag.message.substr(0, index);
		var message = diag.message.substr(index + 3);
		switch (checkName) {
			case DynamicCheck:
				makeDynamicAction(document, actions, diag, message);
			case EmptyPackageCheck:
				makeEmptyPackageAction(document, actions, diag, message);
			case FinalCheck:
				makeFinalAction(document, actions, diag, message);
			case IndentationCheck:
				makeIndentationAction(document, actions, diag, message);
			case ModifierOrderCheck:
				makeModifierOrderAction(document, actions, diag, message);
			case NeedBraces:
				makeNeedBracesAction(document, actions, diag, message);
			case RedundantModifierCheck:
				makeRedundantModifierAction(document, actions, diag, message);
			case StringLiteralCheck:
				makeStringLiteralAction(document, actions, diag, message);
			case TraceCheck:
				makeTraceAction(document, actions, diag, message);
			case UnusedImportCheck:
				makeUnusedImportAction(document, actions, diag, message);
		}
	}

	/**
	 * Creates a code action to resolve the `Dynamic` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/dynamic.html
	 */
	function makeDynamicAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// This action is simple; replace the type Dynamic with the type Any.
		var replace = document.getText(diag.range).replace("Dynamic", "Any");
		replaceAction(actions, "Replace with Any", document, diag.range, diag, replace);

		// Add a code action to insert a SuppressWarning annotation.
		var prefix = document.getText(new Range(diag.range.start.line, 0, diag.range.start.line, diag.range.start.character));
		if (~/\s+/.match(prefix)) {
			prefix = "\n" + prefix;
		} else {
			prefix = " ";
		}
		insertAction(actions, "Suppress warning for Dynamic", document, diag.range.start, diag, '@SuppressWarning("checkstyle:Dynamic")' + prefix);
	}

	/**
	 * Creates a code action to resolve the `EmptyPackage` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/emptypackage.html
	 */
	function makeEmptyPackageAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// The user's config will either demand that an empty package be used on files,
		// or that empty packages be removed from files.
		var code:checkstyle.checks.design.EmptyPackageCheck.EmptyPackageCode = cast diag.code;
		switch (code) {
			case MISSING_PACKAGE:
				// Use an insert action to add the text `package;`
				insertAction(actions, "Add package declaration", document, diag.range.start, diag, "package;\n");
			case REDUNDANT_PACKAGE:
				// Use a delete action to remove the text `package;`
				deleteAction(actions, "Remove package declaration", document, diag.range, diag);
		}
	}

	/**
	 * Creates a code action to resolve the `Final` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/final.html
	 */
	function makeFinalAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// This diagnostic checks for two different use case.
		var code:checkstyle.checks.modifier.FinalCheck.FinalCode = cast diag.code;
		switch (code) {
			case USE_INLINE_FINAL:
				// Here, we replace the `var` keyword with `final`.
				var modifierRange = new Range(diag.range.start, diag.range.start.translate(0, 3));
				replaceAction(actions, "Change to final", document, modifierRange, diag, "final");
			case SHOULD_BE_PUBLIC_FINAL:
				// Here, we change `public var` to `public final`.
				var modifierRange = new Range(diag.range.start, diag.range.start.translate(0, 3));
				replaceAction(actions, "Change to final", document, modifierRange, diag, "final");

				// We also provide the option to change the variable from `public` to `private`.
				var line = document.lineAt(diag.range.start);
				var index = line.text.indexOf("public ");
				if (index < 0) {
					return;
				}
				var modifierPos = document.positionAt(document.offsetAt(line.range.start) + index);
				modifierRange = new Range(modifierPos, modifierPos.translate(0, 6));
				replaceAction(actions, "Change to private", document, modifierRange, diag, "private");
		}

		// Add a code action to insert a SuppressWarning annotation.
		var prefix = document.getText(new Range(diag.range.start.line, 0, diag.range.start.line, diag.range.start.character));
		if (~/\s+/.match(prefix)) {
			prefix = "\n" + prefix;
		} else {
			prefix = " ";
		}
		insertAction(actions, "Suppress warning for non-final var", document, diag.range.start, diag, '@SuppressWarning("checkstyle:Final")' + prefix);
	}

	/**
	 * Creates a code action to resolve the `Indentation` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/indentation.html
	 */
	function makeIndentationAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// Quick trick; just use RegEx on the message to determine the expected value.
		var reg = ~/expected: "([^"]+)"/;
		if (!reg.match(message)) {
			return;
		}
		var replacement = reg.matched(1).replace("\\t", "\t");
		// Create a code action which replaces the offending indentation with the expected value.
		replaceAction(actions, "Fix indentation", document, diag.range, diag, replacement);
	}

	/**
	 * Creates a code action to resolve the `ModifierOrder` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/modifierorder.html
	 */
	function makeModifierOrderAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// Extract the expected and actual values from the problem message.
		var reg = ~/ is "([^"]+)" but should be "([^"]+)"/;
		if (!reg.match(message)) {
			return;
		}
		var actual = reg.matched(1);
		var expected = reg.matched(2);
		// Search the relevant line of the document for the actual value.
		var line = document.lineAt(diag.range.start);
		var index = line.text.indexOf(actual + " ");
		if (index < 0) {
			return;
		}
		// Start position of the actual text.
		var startPos = document.positionAt(document.offsetAt(line.range.start) + index);
		// Range of positions for the actual text.
		var modifierRange = new Range(startPos, startPos.translate(0, actual.length));
		// Create a code action which replaces the text at the position of the specified actual value
		// with the text of the expected value.
		replaceAction(actions, "Adjust modifier order", document, modifierRange, diag, expected);
	}

	/**
	 * Creates a code action to resolve the `NeedBraces` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/needbraces.html
	 * 
	 * Examples of code to correct:
	 * @see https://github.com/HaxeCheckstyle/haxe-checkstyle/blob/dev/test/checkstyle/checks/block/NeedBracesCheckTest.hx
	 */
	function makeNeedBracesAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// This rule handles a total of four cases.
		// Either there is a missing public/private modifier or a redundant public/private modifier..
		var code:checkstyle.checks.block.NeedBracesCheck.NeedBracesCheckToken = cast diag.code;

		// Check if the issue is with allowSingleLineStatement.
		var reg = ~/Body of "([_a-z]+)" on same line/;
		if (reg.match(message)) {
			// Violation of allowSingleLineStatement.
			// Add a code action to move the code to the next line, with appropriate indentation.

			// Start at one level of indent.
			// TODO: Can we get the current tab size/style from the VSCode settings?
			var indent = "  ";
			// Get the indentation of the text before the violation.
			var prefix = document.getText(new Range(diag.range.start.line, 0, diag.range.start.line, diag.range.start.character));
			var prefixReg = ~/^(\s+).*/;
			// Add in any indentation the parent statement had.
			if (prefixReg.match(prefix)) {
				indent += prefixReg.matched(1);
			}

			// Insert a new line at the beginning of the problem range.
			insertAction(actions, "Move statement body to next line", document, diag.range.start, diag, '\n$indent');
		} else {
			// Else, we need to add braces to the code block!
			var prevLine = document.lineAt(diag.range.start.line - 1);
			var endOfPrevLine = prevLine.range.end;

			var endOfLine = diag.range.end;

			// Start with no indentation.
			var prefix = '';
			// Add in any indentation the parent statement had.
			var prefixReg = ~/^(\s+).*/;
			if (prefixReg.match(prevLine.text)) {
				prefix += prefixReg.matched(1);
			}

			// Create two actions for this, one to add the opening brace and one for the closing brace.
			// These will be later combined into one code action.
			insertAction(actions, "Add braces to statement", document, endOfPrevLine, diag, ' {');
			insertAction(actions, "Add braces to statement", document, endOfLine, diag, '\n$prefix}');
		}
	}
    
	/**
	 * Creates a code action to resolve the `RedundantModifier` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/redundantmodifier.html
	 */
	function makeRedundantModifierAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// This rule handles a total of four cases.
		// Either there is a missing public/private modifier or a redundant public/private modifier..
		var code:checkstyle.checks.modifier.RedundantModifierCheck.RedundantModifierCode = cast diag.code;
		switch (code) {
			case MISSING_PUBLIC, MISSING_PRIVATE:
				// The codestyle config specified the public or private modifier is mandatory. Create a code action to insert it.
				var modifier = (code == MISSING_PUBLIC) ? "public" : "private";
				insertAction(actions, "Add public/private modifier", document, diag.range.start, diag, '$modifier ');
			case REDUNDANT_PUBLIC, REDUNDANT_PRIVATE:
				// The codestyle config specified the public or private modifier should be removed. Create a code action to remove it.
				var modifier = (code == REDUNDANT_PUBLIC) ? "public" : "private";
				var line = document.lineAt(diag.range.start);
				var index = line.text.indexOf('$modifier ');
				if (index == -1) {
					return;
				}
				var modifierPos = document.positionAt(document.offsetAt(line.range.start) + index);
				var modifierRange = new Range(modifierPos, modifierPos.translate(0, modifier.length + 1));
				deleteAction(actions, "Remove public/private modifier", document, modifierRange, diag);
		}
	}

	/**
	 * Creates a code action to resolve the `StringLiteral` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/stringliteral.html
	 */
	function makeStringLiteralAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// This handles two cases; either the config demands double quotes or single quotes.
		var code:checkstyle.checks.literal.StringLiteralCheck.StringLiteralCode = cast diag.code;
		var text:String = null;
		var quote:String = null;
		// Figure out what the expected value is.
		switch (code) {
			case USE_DOUBLE_QUOTES:
				text = "Change single quotes to double quotes";
				quote = '"';
			case USE_SINGLE_QUOTES:
				text = "Change double quotes to single quotes";
				quote = "'";
		}
		if (text == null) {
			return;
		}
		// Create a code action which replaces the first quote.
		var quoteRange = new Range(diag.range.start, diag.range.start.translate(0, 1));
		replaceAction(actions, text, document, quoteRange, diag, quote);
		// Create a code action which replaces the second quote.
		// Since it has the same title, the actions will be combined later.
		quoteRange = new Range(diag.range.end, diag.range.end.translate(0, -1));
		replaceAction(actions, text, document, quoteRange, diag, quote);
	}

	/**
	 * Creates a code action to resolve the `Trace` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/trace.html
	 */
	function makeTraceAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		// Add an action which deletes the trace call.
		deleteAction(actions, "Delete trace", document, diag.range, diag);

		// Add an action which adds a suppression annotation to ignore the warning.
		var prefix = document.getText(new Range(diag.range.start.line, 0, diag.range.start.line, diag.range.start.character));
		if (~/\s+/.match(prefix)) {
			prefix = "\n" + prefix;
		} else {
			prefix = " ";
		}
		insertAction(actions, "Suppress warning for trace", document, diag.range.start, diag, '@SuppressWarning("checkstyle:Trace")' + prefix);
	}

	/**
	 * Creates a code action to resolve the `UnusedImport` issue.
	 * @see http://haxecheckstyle.github.io/docs/haxe-checkstyle/unusedimport.html
	 */
	function makeUnusedImportAction(document:TextDocument, actions:Map<String, CodeAction>, diag:Diagnostic, message:String) {
		var line = document.lineAt(diag.range.start);
		var importRange = diag.range;
		if (line.range.isEqual(diag.range)) {
			importRange = new Range(diag.range.start, new Position(importRange.end.line + 1, 0));
		}

		var code:checkstyle.checks.imports.UnusedImportCheck.UnusedImportCode = cast diag.code;
		switch (code) {
			case UNUSED_IMPORT, TOPLEVEL_IMPORT, SAME_PACKAGE, DUPLICATE_IMPORT:
				// We found an unused, unnecessary, or duplicate import.
				// Create a code action to delete the line.
				deleteAction(actions, "Remove unused imports", document, importRange, diag);
			case MULTIPLE_PACKAGE:
				// We found an instance where multiple packages are specified on one line...?
		}
	}

	/**
	 * Access the `actions` map based on the title, and either add to the existing action or create a new one.
	 *
	 * This is what causes multiple code actions to be combined into one if the action already exists.
	 */
	function createOrGetAction(actions:Map<String, CodeAction>, title:String, diagnostic:Diagnostic):CodeAction {
		// Append to the existing action with the same name.
		if (actions.exists(title)) {
			var action = actions.get(title);
			action.diagnostics.push(diagnostic);
			return action;
		}
		// Create a new action with this name.
		var action = new CodeAction(title, CodeActionKind.QuickFix);
		action.diagnostics = [diagnostic];
		action.edit = new WorkspaceEdit();
		actions.set(title, action);
		return action;
	}

	/**
	 * Access the `actions` map to get the 'Fix all' action, and add onto it.
	 */
	function createOrGetFixAllAction(actions:Map<String, CodeAction>, diagnostic:Diagnostic):CodeAction {
		// Use existing action with this name.
		if (actions.exists(TITLE_FIX_ALL)) {
			var action = actions.get(TITLE_FIX_ALL);
			action.diagnostics.push(diagnostic);
			return action;
		}
		// Create a new action with this name.
		var action = new CodeAction(TITLE_FIX_ALL, CodeActionKind.SourceFixAll);
		action.diagnostics = [diagnostic];
		action.edit = new WorkspaceEdit();
		actions.set(TITLE_FIX_ALL, action);
		return action;
	}

	/**
	 * Utility function that creates a code action which, when run, will insert text at the given position.
	 * 
	 * @param actions The list of code actions already built for this context.
	 * @param title The displayed text for this code action.
	 * @param diagnostic The problem to be resolved.
	 * 
	 * @param document The document to modify.
	 * @param pos The position to insert at.
	 * @param insertText The text to insert.
	 */
	function insertAction(actions:Map<String, CodeAction>, title:String, document:TextDocument, pos:Position, diagnostic:Diagnostic, insertText:String) {
		var action:CodeAction = createOrGetAction(actions, title, diagnostic);
		action.edit.insert(document.uri, pos, insertText);
		var fixAll:CodeAction = createOrGetFixAllAction(actions, diagnostic);
		fixAll.edit.insert(document.uri, pos, insertText);
	}

	/**
	 * Utility function that creates a code action which, when run, will replace the given range with the given text.
	 *
	 * @param actions The list of code actions already built for this context.
	 * @param title The displayed text for this code action.
	 * @param diagnostic The problem to be resolved.
	 * 
	 * @param document The document to modify.
	 * @param range The range to remove and insert new text at.
	 * @param replaceText The text to insert in place of the range.
	 */
	function replaceAction(actions:Map<String, CodeAction>, title:String, document:TextDocument, range:Range, diagnostic:Diagnostic, replaceText:String) {
		var action:CodeAction = createOrGetAction(actions, title, diagnostic);
		action.edit.replace(document.uri, range, replaceText);
		var fixAll:CodeAction = createOrGetFixAllAction(actions, diagnostic);
		fixAll.edit.replace(document.uri, range, replaceText);
	}

	/**
	 * Utility function that creates a code action which, when run, will delete the text in the given range.
	 * 
	 * @param actions The list of code actions already built for this context.
	 * @param title The displayed text for this code action.
	 * @param diagnostic The problem to be resolved.
	 * 
	 * @param document The document to modify.
	 * @param range The range to delete.
	 */
	function deleteAction(actions:Map<String, CodeAction>, title:String, document:TextDocument, range:Range, diagnostic:Diagnostic) {
		var action:CodeAction = createOrGetAction(actions, title, diagnostic);
		action.edit.delete(document.uri, range);
		var fixAll:CodeAction = createOrGetFixAllAction(actions, diagnostic);
		fixAll.edit.delete(document.uri, range);
	}
}

/**
 * An enumeration of all the checkstyle rules that the extension will generate code actions for.
 */
enum abstract CheckNames(String) from String {
	var DynamicCheck = "Dynamic";
	var EmptyPackageCheck = "EmptyPackage";
	var FinalCheck = "Final";
	var IndentationCheck = "Indentation";
	var ModifierOrderCheck = "ModifierOrder";
	var NeedBraces = "NeedBraces";
	var RedundantModifierCheck = "RedundantModifier";
	var StringLiteralCheck = "StringLiteral";
	var TraceCheck = "Trace";
	var UnusedImportCheck = "UnusedImport";
}
